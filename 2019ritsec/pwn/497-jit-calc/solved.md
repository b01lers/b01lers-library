solved by nsnc
Do some reversing and find that this program mmaps some memory and lets you execute it. Read input -> write code. The program allows you to write raw bytes into specified registers, we can either write a constant to memory or add registers. The bug we exploited is the line if (code_here + 0x3d9 <= cur_code_index) { return; }. If we get past that we can't write any more and it'll exit, while usually you'd be required to put a return at the end of your instructions, but if we fill up this buffer, it won't be able to write a return to the end of the buffer, so we can write a longer string first and a shorter string second, so the instructions will overlap incorrectly (add and fp are different lengths).